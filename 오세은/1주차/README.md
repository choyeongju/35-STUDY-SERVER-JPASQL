# SECTION 2 프로젝트 환경설정

## 💠프로젝트 생성

**Project: Gradle**  
maven과 gradle은 둘 다 빌드 도구(build tool)
옛날에 만들어진 프로젝트들은 주로 maven을 사용하였고, 최근에 만들어진 프로젝트들은 주로 gradle을 사용한다.

**사용 기능: web, thymeleaf, jpa, h2, lombok**  

## 💠View 환경 설정

**thymeleaf - natural templates**   

* 장점 - 마크업을 깨지 않고 그대로 사용, 웹 브라우저에서 열림   
* 단점 - 2.x에서의 극단적인 단점 - <br>태크 닫아주지 않으면 에러 생김. 3.x에서는 개선됨

template 명(화면 이름)을 반환하고, template명 뒤에 .html이 자동으로 붙인다.

정적인 content는 static 폴더에, 템플릿 렌더링이 필요한 content는 templates 폴더에 구분한다.

## 💠H2 데이터베이스 설치
윈도우의 경우, 파일 경로에서 h2.bat으로 h2 db 실행한다.

1. 최소 한 번, 세션키 유지한 상태로 `jdbc:h2:~/jpashop` 실행
2. `~/jpashop>mv.db` 파일 생성 확인
3. 이후부터는 jdbc:h2:tcp://localhost/~/jpashop 이렇게 접속

> 위의 절차로 하면 된다고 했으나, `jdbc:h2:~/jpashop`으로 db 실행이 안되길래,   
> 1. c드라이브/사용자/USER 경로에 jpashop..mv.db 파일 생성
> 2. 바로 `jdbc:h2:tcp://localhost/~/jpashop` 로 접속

## 💠JPA와 DB 설정, 동작확인
`Application.properties` 또는 `application.yml` 둘 중 하나를 선택하면 되지만, 설정 파일이 많아지고 복잡해지면 application.yml이 더 좋다.

쿼리파라미터 로그 남기기
```java

logging:
  level:
    org.hibernate.type: trace
```
hibernate 로거의 type을 trace로 해도 log 안남음
org.hibernate.type 대신 `org.hibernate.orm.jdbc.bind: trace` 으로 변경하면, 로그가 잘 나온다.

하지만, 그럼에도 values()는 ?로 표시된다.

→ 외부 라이브러리 사용(spring-boot-data-source-decorator)
데이터 베이스 커넥션을 랩핑해서 만들어진 sql statement를 이해해서 로그를 출력해주는 라이브러리

```java
implementation("com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.10.0")
```
**[참고]**  
* 버전을 따로 적어주는 이유    
기본적으로 스프링부트에 가장 적합한 라이브러리 버전들을 setting해놓기 때문에,    
그런 라이브러리들은 버전을 적어주지 않아도 되지만, 스프링부트가 기본적으로 버전을 설정하지 않는 라이브러리는 따로 버전 정보를 적어주어야 한다.


> 쿼리 파라미터를 로그로 남기는 외부 라이브러리는 시스템 자원을 사용하므로, 개발 단계에서는 편하게 사용해도 된다.   
> 다만, 운영 단계(배포)에서 적용하려면 성능 테스트를 하고 사용하는 것이 좋다. (병목될 수 있음)


# SECTION 3 도메인 분석 설계

## 💠 도메인 모델과 테이블 설계
* 주문-상품과 같은 다대다 관계는 관계형 DB와 엔티티에서 거의 사용하지 않는다.   
따라서, 그림처럼 주문상품이라는 엔티티를 추가해서 다대다관계를 일대다, 다대일 관계로 풀어서 나타낸다.


### 연관관계 매핑 분석
양방향 관계의 경우, 연관관계의 주인을 정해야 한다.


* 외래 키가 있는 곳을 연관관계의 주인으로 정할 것.
    * 연관관계의 주인은 단순히 외래 키를 누가 관리하냐의 문제일 뿐, 비즈니스 상 우위에 있다고 주인으로 정하면 안된다.
        * 예를 들어, 자동차와 바퀴가 있을 때, 일대다 관계에서 항상 다쪽에 외래 키가 있으므로, 외래 키가 있는 바퀴를 연관관계의 주인이라고 정하면 된다. 물론 자동차를 연관관계의 주인으로 정하는 것이 불가능한 것은 아니지만, 그렇게 할 경우에는 자동차가 관리하지 않는 바퀴 테이블의 외래 키 값이 업데이트되므로, 관리와 유지보수가 어렵고, 추가적으로 별도의 업데이트 쿼리가 발생하는 성능 문제도 발생한다.


## 💠 엔티티 클래스 개발

* 이론적으로 Getter, Setter를 모두 제공하지 않고, 꼭 필요한 별도의 메서드를 제공하는 게 가장 이성적이나,   
실무에서 엔티티의 데이터는 조죄할 일이 너무 많기 때문에 Getter의 경우 모두 열어두는 것이 편리하다.  
  Getter를 호출하는 것은 어떤 일이 발생하지 않지만, Setter는 호출하면 데이터가 변한다.  
Setter를 막 열어두면 가까운 미래에 엔티티가 왜 변경되는지 추적하기 점점 힘들어진다. 그래서 엔티티를 변경할 때는 Setter 대신에 변경 지점이 명확하도록 변경을 위한 비즈니스 메서드를 별도로 제공해야 한다.


* 엔티티의 식별자는 id 를 사용하고, PK 컬럼명은 member_id 라고 작성하는 이유   
    * 엔티티는 타입(Member)이 있으므로 id 필드만으로 쉽게 구분할 수 있지만, 테이블은 타입이 없으므로 구분이 어렵다.
그리고 테이블은 관례상 테이블명 + id 를 많이 사용한다.   
    * 객체에서 id 대신 memberId 를 사용해도 되지만, 중요한 것은 일관성 이다!

## 💠 엔티티 설계 시 주의점

- 엔티티에는 가급적 Setter를 사용하지 말자
    - Setter가 모두 열려있다면, 변경 포인트가 너무 많아서 유지보수가 어렵다


- 모든 연관관계는 지연로딩으로 설정할 것
    - ✨ 즉시로딩(`EAGER` )은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다. 특히 JPQL을 실행할 때, N+1 문제가 자주 발생함
    - 실무에서 모든 연관관계는 지연로딩(`LAZY` )으로 설정해야 한다
    - 연관된 엔티티를 함께 DB에서 조회해야 하면, `fetch join` 또는 엔티티 그래프 기능을 사용할 것.
    - @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 한다
        - cf) @OneToMany → 기본이 지연로딩이다